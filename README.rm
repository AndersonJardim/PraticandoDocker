docker images
docker ps
docker stop $(docker container ls -q)
docker run -p 8080:3000 -d danielartine/app-node:1.0
docker run -p 8080:3000 -d danielartine/app-node:1.0
docker run -d 8080:3000 danielartine/app-node:1.0
http://localhost:8080

# Dockerfile

FROM node:14
WORKDIR /app-node
EXPOSE 3000
COPY . .
RUN npm install
ENTRYPOINT npm start


# Build 1.0
docker build -t andersonjardim/app-node:1.0 .
docker run -d -p 8081:3000 9d2de56785ca andersonjardim/app-node:1.0
http://localhost:8081


# Build 1.1
docker build –t andersonjardim/app-node:1.1 .
docker run -d andersonjardim/app-node:1.1

# Dockerfile

FROM node:14
WORKDIR /app-node
ARG PORT=6000
EXPOSE $PORT
COPY . .
RUN npm install
ENTRYPOINT npm start

# Build 1.2
docker build -t andersonjardim/app-node:1.2 .
docker run -d andersonjardim/app-node:1.2
docker run -p 9090:6000 -d andersonjardim/app-node:1.2



# Dockerfile

FROM node:14
WORKDIR /app-node
ARG PORT_BUILD=6000
ENV PORT=$PORT_BUILD
EXPOSE $PORT_BUILD
COPY . .
RUN npm install
ENTRYPOINT npm start

docker build –t danielartine/app-node:1.2 .
docker run –p 9090:6000 –d danielartine/app-node:1.2
http://localhost:9090

# Build 1.2.2
docker build -t andersonjardim/app-node:1.2 .
docker run -d andersonjardim/app-node:1.2
docker run -p 9090:6000 -d andersonjardim/app-node:1.2

# Difenças de ARV e ENV
ARV é usado em tempo de build.
ENV será usando dentro do container







## Push para o Hub do Docker
docker login -u andersonjardim
---****
docker images
docker tag 0a5f76dd285d andersonjardim/app-node:1.2
docker push andersonjardim/app-node:1.2

Anderson, parabéns pela dedicação aos estudos!
Você mencionou que o comando docker push é utilizado para subir as imagens para o servidor e que, ao subir outra imagem, ele aproveita as camadas. Isso é uma observação importante sobre a eficiência do Docker, pois realmente as imagens são compostas por camadas, e o Docker utiliza um sistema de cache que permite que camadas comuns entre diferentes imagens sejam reutilizadas, economizando espaço e tempo.
Além disso, também vimos que as imagens são imutáveis, o que significa que, uma vez que uma imagem é criada, ela não pode ser alterada. Isso garante que múltiplos containers possam reutilizar a mesma imagem sem risco de modificações indesejadas.
Outra parte importante que você pode considerar é a criação de imagens através de Dockerfiles, que permite automatizar o processo de construção de imagens personalizadas. O comando docker build é fundamental nesse processo, pois ele lê o Dockerfile e cria a imagem conforme as instruções especificadas.
Continue estudando e praticando!


## REVISAO
docker ps
docker ps -a

remover todos os containers
docker rm $(docker ps -aq)
docker container rm $(docker ps -aq)


## apagando tudo
docker rmi $(docker ls -aq)
docker rmi $(docker image ls -aq)
docker rmi $(docker image ls -aq) --force
docker container rm $(docker ps -aq)


## Recomençando 2
docker run -it ubuntu bash
docker ps
docker ps -s
docker history ubuntu

❯ docker history ubuntu
IMAGE          CREATED       CREATED BY                                      SIZE      COMMENT
602eb6fb314b   11 days ago   /bin/sh -c #(nop)  CMD ["/bin/bash"]            0B
<missing>      11 days ago   /bin/sh -c #(nop) ADD file:1d7c45546e94b90e9…   78.1MB
<missing>      11 days ago   /bin/sh -c #(nop)  LABEL org.opencontainers.…   0B
<missing>      11 days ago   /bin/sh -c #(nop)  LABEL org.opencontainers.…   0B
<missing>      11 days ago   /bin/sh -c #(nop)  ARG LAUNCHPAD_BUILD_ARCH     0B
<missing>      11 days ago   /bin/sh -c #(nop)  ARG RELEASE                  0B


